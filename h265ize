#!/usr/bin/env node

"use strict";

const optional = require('optional');
const yargs = require('yargs');
const _ = require("lodash");
const winston = require("winston");
const ffmpeg = require('fluent-ffmpeg');
const mime = require('mime');
const recursive = require('recursive-readdir');
const colors = require('colors');
const moment = require('moment');
require("moment-duration-format");
const filesize = require('filesize');
const fs = require('fs-extra');
const hasbin = require('hasbin');
const math = require('mathjs');
const stripAnsi = require('strip-ansi');

const path = require('path');
const os = require("os");
const readline = require("readline");
const spawn = require('child_process').spawn;

const packageId = 'h265ize';
const version = '0.4.0';
const description = 'h265ize is a fire and forget weapon. A nodejs utility utilizing ffmpeg to encode large quantities of videos with the hevc codec.';

var userSettings = optional("settings.json") || {};

// Parse Options ---------------------------------------------------------------

var args = yargs
    .usage(colors.underline('Usage:') + ' $0 [options] [file|directory]')
    .options({
        'd': {
            alias: 'destination',
            default: userSettings['destination'] || path.resolve(process.cwd(), 'h265'),
            describe: 'Folder where encoded files are output.',
            type: 'string',
            normalize: true,
            group: 'General:'
        },
        'g': {
            alias: 'temp-directory',
            default: userSettings['temp-directory'] || path.resolve(os.tmpdir(), packageId),
            describe: 'Folder where files are stored during encoding.',
            type: 'string',
            normalize: true,
            group: 'General:'
        },
        'log-file': {
            default: userSettings['log-file'] || path.resolve(process.cwd(), 'log.txt'),
            describe: 'Sets the log file location for all output from h265ize. Enable debug mode via the --debug flag to output to the log file.',
            type: 'string',
            normalize: true,
            group: 'General:'
        },
        'm': {
            alias: 'preset',
            default: userSettings['preset'] || 'fast',
            describe: 'x265 encoder preset.',
            choices: ['ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow', 'placebo'],
            type: 'string',
            group: 'General:'
        },
        'as-preset': {
            default: userSettings['as-preset'] || 'none',
            describe: 'My personal presets. Descriptions of each preset\'s use and function can be found on the github page.',
            choices: ['basic', 'testing-anime', 'testing-ssim', 'none'],
            type: 'string',
            group: 'Advanced:'
        },
        'n': {
            alias: 'native-language',
            default: userSettings['native-language'] || '',
            describe: 'The native language used to select default audio and subtitles. You may use 3 letter or 2 letter ISO 639-2 Alpha-3/Alpha-2 codes or the full language name. Examples: [eng|en|English|jpn|ja|Japanese]',
            type: 'string',
            group: 'General:'
        },
        'f': {
            alias: 'output-format',
            default: userSettings['output-format'] || 'mkv',
            describe: 'Output container format.',
            choices: ['mkv', 'mp4', 'm4v'],
            type: 'string',
            group: 'General:'
        },
        'x': {
            alias: 'extra-options',
            default: userSettings['extra-options'] || '',
            describe: 'Extra x265 options. Options can be found on the x265 options page.',
            type: 'string',
            group: 'Advanced:'
        },
        'q': {
            alias: 'quality',
            default: userSettings['quality'] || 19,
            describe: 'Sets the qp quality target',
            type: 'number',
            group: 'General:'
        },
        'video-bitrate': {
            default: userSettings['video-bitrate'] || 0,
            describe: 'Sets the video bitrate, set to 0 to use qp rate control instead of a target bitrate.',
            type: 'number',
            group: 'Advanced:'
        },
        'l': {
            alias: 'preview-length',
            default: userSettings['preview-length'] || 30000,
            describe: 'Milliseconds to encode in preview mode. Max is half the length of input video.',
            type: 'number',
            group: 'Advanced:'
        },
        'time-drift-limit': {
            default: userSettings['time-drift-limit'] || 200,
            describe: 'Milliseconds the finished encode is allowed to differ from the original\'s length.',
            type: 'number',
            group: 'Advanced:'
        },
        // 'depth': {
        //     default: 2,
        //     describe: 'How deep the search for video files should go in subdirectories.',
        //     type: 'number',
        //     group: 'Advanced:'
        // },
        'accurate-timestamps': {
            default: userSettings['accurate-timestamps'] || false,
            describe: 'Become blu-ray complient and reduce the max keyInt to the average frame rate.',
            type: 'boolean',
            group: 'Advanced:'
        },
        'he-audio': {
            default: userSettings['he-audio'] || false,
            describe: 'Re-encode audio to opus at 48kb/s.',
            type: 'boolean',
            group: 'Advanced:'
        },
        'force-he-audio': {
            default: userSettings['force-he-audio'] || false,
            describe: 'Convert all audio to HE format, including lossless formats.',
            type: 'boolean',
            group: 'Advanced:'
        },
        'downmix-he-audio': {
            default: userSettings['downmix-he-audio'] || false,
            describe: 'Downmix he-audio opus to Dolby Pro Logic II at 96kb/s. Enables he-audio.',
            type: 'boolean',
            group: 'Advanced:'
        },
        'o': {
            alias: 'override',
            default: userSettings['override'] || false,
            describe: 'Enable override mode. Allows conversion of videos that are already encoded by the hevc codec.',
            type: 'boolean',
            group: 'Advanced:'
        },
        'p': {
            alias: 'preview',
            default: userSettings['preview'] || false,
            describe: 'Only encode a preview of the video starting at middle of video. See -l/--preview-length for more info.',
            type: 'boolean',
            group: 'General:'
        },
        'disable-upconvert': {
            default: userSettings['disable-upconvert'] || false,
            describe: 'Disable Upconvert. Stop converting Vobsub subs to srt. Only works with mkv\'s.',
            type: 'boolean',
            group: 'Advanced:'
        },
        'stats': {
            default: userSettings['stats'] || false,
            describe: 'Output a stats file containing stats for each video converted.',
            type: 'boolean',
            group: 'Advanced:'
        },
        'v': {
            alias: 'verbose',
            default: userSettings['verbose'] || false,
            describe: 'Enables verbose mode. Prints extra information.',
            type: 'boolean',
            group: 'Advanced:'
        },
        '10bit': {
            default: userSettings['10bit'] || false,
            describe: 'Forces encoding videos in 10bit format (Useful for anime).',
            type: 'boolean',
            group: 'Advanced:'
        },
        '12bit': {
            default: userSettings['12bit'] || false,
            describe: 'Forces encoding videos in 12bit format (Useful for anime).',
            type: 'boolean',
            group: 'Advanced:'
        },
        'screenshots': {
            default: userSettings['screenshots'] || false,
            describe: 'Take 6 screenshots at regular intervals throughout the finished encode.',
            type: 'boolean',
            group: 'Advanced:'
        },
        'debug': {
            default: userSettings['debug'] || false,
            describe: 'Enables debug mode. Prints extra debugging information.',
            type: 'boolean',
            group: 'Advanced:'
        },
        'delete': {
            default: userSettings['delete'] || false,
            describe: 'Delete source after encoding is complete and replaces it with new encode. [DANGER]',
            type: 'boolean',
            group: 'Advanced:'
        },
        'test': {
            default: userSettings['test'] || false,
            describe: 'Puts h265ize in test mode. No files will be encoded.',
            type: 'boolean',
            group: 'Options:'
        },
        'help': {
            describe: 'Displays help page.',
            group: 'Options:'
        },
    })
    .argv;


// Enable Logger ---------------------------------------------------------------

var logLevels = {
    levels: {
        error: 0,
        warn: 1,
        alert: 2,
        info: 3,
        verbose: 4,
        debug: 5
    },
    colors: {
        error: 'red',
        warn: 'yellow',
        alert: 'magenta',
        info: 'white',
        verbose: 'cyan',
        debug: 'grey'
    }
};
var logLevel = args.debug ? 'debug' : args.verbose ? 'verbose' : 'info';

winston.addColors(logLevels.colors);
var lastLineWasCleared = false;
var logger = new(winston.Logger)({
    levels: logLevels.levels,
    transports: [
        new(winston.transports.Console)({
            level: logLevel,
            colorize: true,
            label: packageId,
            prettyPrint: true,
            // handleExceptions: true,
            // humanReadableUnhandledException: true,
            // timestamp: function() {
            //     return Date.now();
            // },
            formatter: function(options) {
                let packageId = options.level === 'error' ? colors[logLevels.colors['error']]('[' + options.label + ']') : colors.green('[' + options.label + ']');
                let logLevel = (options.level === 'info' || options.level === 'error') ? '' : colors[logLevels.colors[options.level]]('[' + options.level + ']') + ' ';
                return packageId + ': ' + logLevel +
                    (undefined !== options.message ? options.message : '') +
                    (options.meta && Object.keys(options.meta).length ? createListString(options.meta) : '');
            }
        }),
    ],
    filters: [
        function(level, msg, meta) {
            if (meta.__divider)
                msg = msg + '\n' + '-'.repeat(process.stdout.columns);

            delete meta.__clearLine;
            delete meta.__divider;
            return msg;
        }
    ],
    rewriters: [
        function(level, msg, meta) {
            if (meta.__clearLine && lastLineWasCleared) {
                readline.moveCursor(process.stdout, -1000, -1);
                readline.clearLine(process.stdout, 0);
                lastLineWasCleared = true;
            }
            else if (meta.__clearLine) {
                lastLineWasCleared = true;
            }
            else {
                lastLineWasCleared = false;
            }

            return meta;
        }
    ]
});

// Show help
if (args.help) {
    console.log(colors.underline('Package:'), colors.yellow(packageId), '\t', colors.underline('Version:'), colors.yellow(version));
    console.log(colors.underline('Descriptions:'), description);
    yargs.showHelp();
    process.exit(0);
}

if (args.debug) {
    logger.debug('Log file location:', args.logFile);
    logger.add(winston.transports.File, {
        filename: args.logFile,
        level: logLevel,
        label: packageId,
        prettyPrint: true,
        json: false,
        timestamp: false,
        formatter: function(options) {
            let packageId = '[' + options.label + ']';
            let logLevel = (options.level === 'info' || options.level === 'error') ? '' : '[' + options.level + ']' + ' ';
            return stripAnsi(packageId + ': ' + logLevel +
                (undefined !== options.message ? options.message : '') +
                (options.meta && Object.keys(options.meta).length ? createListString(options.meta) : ''));
        }
    });
}

// Setup stats file ------------------------------------------------------------

// var csvStream = csv
//     .createWriteStream({headers: true})
//     .transform(function(row){
//         return {
//           A: row.a,
//           B: row.b
//         };
//     }),
//     writableStream = fs.createWriteStream("my.csv");

// Ensure directories exist ----------------------------------------------------

// Check destination directory
fs.ensureDir(args.destination, function(err) {
    if (err) {
        throw err;
    }
});
// Check temp directory
fs.ensureDir(args.tempDirectory, function(err) {
    if (err) {
        throw err;
    }
});

// Watch for unclean shutdowns -------------------------------------------------

var temp = {
    files: [],
    commandQueue: []
};
process.on('SIGINT', function() {
    readline.clearLine(process.stdout, 0);
    readline.moveCursor(process.stdout, -1000, 0);
    logger.warn('Caught signal interupt! Attempted to clean up.');
    cleanUp(true);
});
process.on('uncaughtException', (err) => {
    logger.error(err);
    cleanUp(true);
});

// Special Features ------------------------------------------------------------



// Set aspreset values -----------------------------------------------------------
logger.verbose('Setting as-preset options...');

var asPresetParams = {};

switch (args.asPreset) {
    case 'basic':
        asPresetParams['preset'] = 'fast';
        asPresetParams['quality'] = '19';
        break;

    case 'testing-anime':
        asPresetParams['preset'] = 'medium';
        asPresetParams['quality'] = '19';

        let x265Options = 'allow-non-conformance:ref=8:bframes=8:rd=6:me=star:b-adapt=2:qg-size=64:rc-lookahead=40:scenecut=45:weightb=1:psy-rd=2.0';

        addx265Options(x265Options);
        break;

    case 'none':
        break;

    default:
        logger.error('Unknown as-preset option', colors.yellow(args.asPreset) + '.');
        process.exit(1);
        break;
}

_.each(asPresetParams, function(val, key) {
    ifNotSetByUserSet(key, val);
});

// Get Files -------------------------------------------------------------------

var input = args._[0] || './';
var videos = [];
var rejectedVideos = {};
var atLeastVerbose = Boolean(logLevels.levels[logger.transports.console.level] >= 4);

var fileDescriptorStats;
try {
    fileDescriptorStats = fs.lstatSync(input);
}
catch (e) {
    if (e.code === 'ENOENT') {
        logger.error('Input', input, 'does not exist.');
        return process.exit(0);
    }
    throw e;
}

// Check if input is a file
if (fileDescriptorStats.isFile()) {
    if (mime.lookup(input).startsWith('video/')) {
        videos.push(input);
        processVideos(videos);
    }
    else
        logger.error('Input file', "\'" + input + "\'", 'is not a recognized file format.');
}

// Check if input is a directory
else if (fileDescriptorStats.isDirectory()) {
    // Get all files in directory
    findVideos(input).then(function(videoPaths) {
        logger.info('Folder encoding started at', colors.yellow(moment().format("dddd, MMMM Do YYYY, h:mm:ss A")));
        processVideos(videoPaths);
    }).catch(function(err) {
        logger.error(err);
    });
}


// Process Videos --------------------------------------------------------------

function processVideos(videos) {
    if (videos.length > 0) {
        let video = videos.shift();
        let startTime = moment();

        logger.info('Processing', path.basename(video) + "...", {
            __divider: true
        });
        logger.info('Encoding started at', colors.yellow(startTime.format("ddd, h:mm A")));

        processVideo(video).then(function() {
            let endTime = moment();
            let timeDiffMilliseconds = moment.duration(endTime.diff(startTime));
            logger.info('Finished encoding at', colors.yellow(endTime.format("ddd, h:mm A")), '(' + moment.duration(timeDiffMilliseconds).humanize() + ')');
            logger.debug('Finished encoding in', colors.yellow(timeDiffMilliseconds / 1000), 'seconds.');
            processVideos(videos);
        }).catch(function(err) {
            logger.warn(err);
            rejectedVideos[video] = err.message;
            processVideos(videos);
        });
    }
    else {
        finished();
    }
}

function processVideo(video) {
    return new Promise(function(resolve, reject) {
        logger.debug('Path:', video);

        let pathData = path.parse(video);
        pathData.filename = pathData.name + pathData.ext;
        let command = new ffmpeg()
            .input(video).videoCodec('libx265');

        let inputCounter = 0;

        let relativeDestinationDirectory = path.relative(path.dirname(input), pathData.dir);
        let destinationDirectory = path.resolve(args.destination, relativeDestinationDirectory);
        if (args.delete) {
            destinationDirectory = path.dirname(video);
        }

        let fileName = pathData.name + (args.preview ? '-preview' : '') + '.' + args.outputFormat;
        let fileOutput = path.resolve(destinationDirectory, fileName);
        let tempOutput = path.resolve(args.tempDirectory, pathData.name + '.encoding-in-progress.' + args.outputFormat);
        let originalMetadata;

        // Check if output file already exists
        if (!args.preview) {
            try {
                fs.accessSync(fileOutput, fs.F_OK);
                logger.debug('File', colors.yellow(fileOutput), 'already exists.');
                if (!args.delete)
                    return reject({
                        level: 'warn',
                        message: 'Already encoded. Skipping...'
                    });
            }
            catch (e) {}
        }

        // Get video data
        let getMetadata = function(path) {
            return new Promise(function(resolve, reject) {
                logger.verbose('Getting video metadata...');
                ffmpeg.ffprobe(path, function(err, metadata) {
                    if (err) {
                        logger.error(err.message);
                        logger.debug('ffprobe error stack:', err.stack);
                        return reject({
                            level: 'error',
                            message: 'FFPROBE_ERROR'
                        });
                    }

                    logger.debug('Container data:', {
                        duration: moment.duration(metadata.format.duration, 'seconds').format('hh:mm:ss', {
                            trim: false,
                            forceLength: true
                        }),
                        size: filesize(metadata.format.size)
                    });

                    resolve(metadata);
                });
            });
        };


        let processStreams = function(metadata) {
            return new Promise(function(resolve, reject) {
                logger.verbose('Resolving video streams...');

                let videoStreams = [],
                    audioStreams = [],
                    subtitleStreams = [],
                    otherStreams = [];

                // Dissect each video stream
                _.each(metadata.streams, function(stream) {
                    logger.debug('Working on stream:', stream.index);
                    stream.input = 0;

                    // logger.debug(stream);

                    if (!stream.codec_type) {
                        logger.warn('A codec was not provided for stream ' + stream.index + '. Your ffmpeg is most likely out of date. At least version 2.8.2 is recommended.');
                    }

                    switch (stream.codec_type) {
                        case 'video':
                            if (stream.codec_name === 'hevc' && !args.override)
                                return reject({
                                    level: 'warn',
                                    message: 'Already encoded in h265. Skipping... (use the --override flag to encode hevc videos)'
                                });
                            videoStreams.push(stream);
                            break;
                        case 'audio':
                            audioStreams.push(stream);
                            break;
                        case 'subtitle':
                            subtitleStreams.push(stream);
                            break;
                        default:
                            otherStreams.push(stream);
                            break;
                    }
                });

                resolve({
                    metadata: metadata,
                    streams: {
                        videoStreams: videoStreams,
                        audioStreams: audioStreams,
                        subtitleStreams: subtitleStreams,
                        otherStreams: otherStreams
                    }
                });
            });
        };

        let upconvert = function(data) {
            return new Promise(function(resolve, reject) {
                if (args.disableUpconvert || args.test)
                    return resolve(data);

                logger.verbose('Upconverting...');

                let trackUpconvertProcesses = [];

                // Here you can process all subtitles
                _.each(data.streams.subtitleStreams, function(subtitle, i) {

                    // Detect dvdsub subtitles
                    if (subtitle.codec_name === 'dvdsub') {

                        // Convert dvdsub subtitle to srt
                        trackUpconvertProcesses.push(new Promise(function(resolve, reject) {
                            extractTrack(video, subtitle.index).then(vobsubToSRT).then(function(filePath) {
                                delete data.streams.subtitleStreams[i];
                                command.input(filePath);
                                subtitle.input = ++inputCounter;
                                resolve();
                            }).catch(reject);
                        }));
                    }
                });

                logger.debug('Upconverting', trackUpconvertProcesses.length, 'tracks.');
                // Execute all upconvert processes
                Promise.all(trackUpconvertProcesses).then(function() {
                    resolve(data);
                }).catch(reject);

            });
        };

        let setVideoBitDepth = function(data) {
            return new Promise(function(resolve, reject) {
                logger.verbose('Setting video bit depth...');

                // Video streams
                let videoIndex = 0,
                    videoBitDepth = 8;

                if (data.streams.videoStreams.length > 1) {
                    // TODO implement feature
                    logger.alert('More than one video stream detected. Using the video stream with the greatest duration.');
                    videoIndex = 0;
                }
                let videoStream = data.videoStream = data.streams.videoStreams[videoIndex];

                // Check for 12bit or 10bit video
                if (videoStream.pix_fmt.indexOf('12le') > -1 || videoStream.pix_fmt.indexOf('12be') > -1) {
                    videoBitDepth = 12;
                }
                else if (videoStream.pix_fmt.indexOf('10le') > -1 || videoStream.pix_fmt.indexOf('10be') > -1) {
                    videoBitDepth = 10;
                }
                data.videoBitDepth = videoBitDepth;

                // Set video encoding profile
                if (userSetOption('12bit')) {
                    command.outputOptions('-pix_fmt', 'yuv420p12le');
                }
                else if (userSetOption('10bit')) {
                    command.outputOptions('-pix_fmt', 'yuv420p10le');
                }
                else {
                    switch (data.videoBitDepth) {
                        case 16:
                            command.outputOptions('-pix_fmt', 'yuv420p16le');
                            break;
                        case 14:
                            command.outputOptions('-pix_fmt', 'yuv420p14le');
                            break;
                        case 12:
                            command.outputOptions('-pix_fmt', 'yuv420p12le');
                            break;
                        case 10:
                            command.outputOptions('-pix_fmt', 'yuv420p10le');
                            break;
                        default:
                            command.outputOptions('-pix_fmt', 'yuv420p');
                            break;
                    }
                }

                resolve(data);
            });
        };

        let mapStreams = function(data) {
            return new Promise(function(resolve, reject) {
                logger.verbose('Mapping streams...');
                data.defaultAudioIndex = null;
                data.defaultSubtitleIndex = null;

                command.outputOptions('-map', data.videoStream.input + ':' + data.videoStream.index);
                logger.debug('Video stream with index', data.videoStream.index, 'mapped.', {
                    size: data.videoStream.width + 'x' + data.videoStream.height,
                    codec: data.videoStream.codec_long_name,
                    profile: data.videoStream.profile,
                    'bit depth': data.videoBitDepth
                });

                // Handle native language detection and default audio track selection
                _.each(data.streams.audioStreams, function(stream, i) {
                    let normalizedLanguage = normalizeStreamLanguage(stream);
                    if (normalizedLanguage === normalizeLanguage(args['native-language']) && !data.defaultAudioIndex) {
                        data.defaultAudioIndex = stream.index;
                    }
                });

                // Audio streams
                _.each(data.streams.audioStreams, function(stream, i) {

                    let audioTitle = getStreamTitle(stream);
                    let normalizedLanguage = normalizeStreamLanguage(stream);

                    command.outputOptions('-map', stream.input + ':' + stream.index);
                    if (!(audioTitle)) {
                        let channelsFormated = stream.channels === 2 ? 'Stereo' : stream.channels % 2 ? (stream.channels - 1) + '.1 Channel' : stream.channels + '.0 Channel';
                        let newTitle = normalizedLanguage + ' ' + stream.codec_name.toUpperCase() + ((stream.profile && stream.profile !== 'unknown') ? (' ' + stream.profile) : '') + ' (' + channelsFormated + ')';
                        logger.alert('Audio does not have a title. Title set to', '"' + newTitle + '".');
                        command.outputOptions('-metadata:s:a:' + stream.index, 'title="' + newTitle);
                    }

                    // Set default audio
                    if (data.defaultAudioIndex && data.defaultAudioIndex === stream.index) {
                        command.outputOptions('-metadata:s:a:' + i, 'DISPOSITION:default=1');
                    }

                    let extraInfo = {
                        title: audioTitle,
                        language: normalizedLanguage,
                        codec: stream.codec_long_name,
                        channels: stream.channels
                    };

                    if (stream.profile)
                        extraInfo.profile = stream.profile;
                    else
                        extraInfo['bit-depth'] = stream.bits_per_raw_sample;

                    logger.debug('Audio stream with index', stream.index, 'mapped.', extraInfo);
                });

                // Subtitle streams
                _.each(data.streams.subtitleStreams, function(stream, i) {

                    // Handle native language
                    let normalizedLanguage = normalizeStreamLanguage(stream);
                    if (normalizedLanguage === normalizeLanguage(args['native-language']) && !data.defaultAudioIndex && !data.defaultSubtitleIndex) {
                        data.defaultSubtitleIndex = stream.index;
                    }


                    command.outputOptions('-map', stream.input + ':' + stream.index);
                    if (!getStreamTitle(stream)) {
                        logger.alert('Subtitle does not have a title. Title set to', normalizedLanguage + '.');
                        command.outputOptions('-metadata:s:s:' + i, 'title=' + normalizedLanguage);
                    }
                    command.outputOptions('-metadata:s:s:' + i, 'DISPOSITION:default=0');
                    logger.debug('Subtitle stream with index', stream.index, 'mapped.', {
                        title: getStreamTitle(stream),
                        language: normalizedLanguage,
                        codec: stream.codec_long_name
                    });
                });

                // Other streams (Attachments: fonts, pictures, etc.)
                _.each(data.streams.otherStreams, function(stream, i) {
                    command.outputOptions('-map', stream.input + ':' + stream.index);
                    logger.debug('Other stream with index', stream.index, 'mapped.');
                });

                resolve(data);
            });
        };

        let setArguments = function(data) {
            return new Promise(function(resolve, reject) {
                logger.verbose('Setting ffmpeg settings...');

                // Preview Mode
                if (args.preview) {
                    command.seekInput(data.metadata.format.duration / 2).duration(args.previewLength / 1000);
                }

                // Set audio codec
                command.audioCodec('copy');

                // High Efficiency audio
                if (args.heAudio) {
                    _.each(data.streams.audioStreams, function(stream, i) {
                        if (stream.codec_name !== 'flac' || args.forceHeAudio) {
                            let bitrate = 64 * stream.channels / 2;
                            command.outputOptions('-c:a:' + i, 'libopus');
                            command.outputOptions('-b:a:' + i, bitrate + 'k');
                            command.outputOptions('-frame_duration', 60);
                            if (args.downmixHeAudio && stream.channels > 3) {
                                // Downmix HE Audio
                                command.audioChannels(2).audioFilters('aresample=matrix_encoding=dplii');
                            }
                        }
                        else {
                            logger.alert('Audio stream', colors.yellow(getStreamTitle(stream) + ' (index: ' + stream.index + ')'), 'won\'t be encoded with HE Audio because it is already in FLAC (lossless) format.');
                        }
                    });
                }

                // Accurate Timestamps
                if (args.accurateTimestamps)
                    addx265Options('keyint=' + math.eval(data.videoStream['avg_frame_rate']).toFixed(0));

                // Set subtitle codec
                command.outputOptions('-c:s', 'copy');

                // Video bitrate target or constant quality?
                if (args.videoBitrate) {
                    command.videoBitrate(args.videoBitrate);
                }
                else {
                    command.outputOptions('-x265-params', 'crf=' + args.quality);
                }

                // H265 preset
                if (args.preset)
                    command.outputOptions('-preset', args.preset);

                // H265 extra options
                if (args.x)
                    command.outputOptions('-x265-params', args.x);

                resolve(data);
            });
        };

        let encodeVideo = function(data) {
            return new Promise(function(resolve, reject) {
                logger.verbose('Encoding video...');
                let startTime = moment();

                if (args.test)
                    return reject({
                        level: 'debug',
                        message: 'Test mode! Skipping...'
                    });



                // Make output directory
                if (!args.delete)
                    fs.ensureDir(destinationDirectory, function(err) {
                        if (err) {
                            logger.warn(video, 'was unable to be encoded. The following error was given:');
                            logger.warn(err);
                        }
                    });

                let commandIndex;
                let tempFileIndex;
                let frameRate = math.eval(data.videoStream.avg_frame_rate);
                if (!args.parallel) {
                    commandIndex = temp.commandQueue.push(command);
                    command.save(tempOutput);
                }

                command
                    .on('progress', function(progress) {
                        let precent = progress.percent ? progress.percent.toFixed(1) + '%' : '';
                        let elapsed = moment().diff(startTime);
                        let elapsedFormated = moment.duration(moment.duration(elapsed), 'seconds').format('hh:mm:ss', {
                            trim: false,
                            forceLength: true
                        });
                        // let speed = 'x' + getSpeedRatio(progress.timemark, elapsed);
                        let speed = 'x' + (progress.currentFps / frameRate).toFixed(3);

                        logger.info(colors.bgMagenta.white('[ffmpeg]'), 'Processing:', progress.currentFps + 'fps', precent, '[' + progress.timemark + ']', '|', colors.yellow(elapsedFormated), colors.yellow('[' + speed + ']'), {
                            __clearLine: true
                        });
                    })
                    .on('start', function(commandLine) {
                        tempFileIndex = temp.files.push(tempOutput);
                        logger.debug('Running Query:', commandLine);
                    })
                    .on('stdout', function(stderrLine) {
                        logger.info(colors.bgMagenta.white('[ffmpeg]'), stderrLine, {
                            __clearLine: true
                        });
                    })
                    .on('end', function() {
                        _.pullAt(temp.commandQueue, commandIndex);
                        logger.verbose(pathData.filename, 'encoded.');
                        resolve(tempFileIndex);
                    })
                    .on('error', function(err, stdout, stderr) {
                        _.pullAt(temp.commandQueue, commandIndex);
                        logger.debug(err.stack);

                        if (err.message.startsWith('ffmpeg was killed with signal'))
                            reject('ENDING');
                        else
                            reject({
                                level: 'error',
                                message: err.message
                            });
                    });

                if (args.parallel) {
                    temp.commandQueue.push(command);
                }
            });
        };

        let verifyEncode = function(tempFileIndex) {
            return new Promise(function(resolve, reject) {
                logger.verbose('Verifying encoded video...');

                getMetadata(tempOutput).then(function(metadata) {
                    logger.debug('Original Duration:', originalMetadata.format.duration, '\t', 'New Duration:', metadata.format.duration);
                    let timeDiff = (originalMetadata.format.duration - metadata.format.duration) * 1000;
                    if (timeDiff > args['time-diff-limit'] && !args.preview) {
                        logger.warn('New encode is', moment.duration(timeDiff).format(), 'longer than the original. The max is', args['time-diff-limit'] + '.');
                        fs.unlinkSync(tempOutput);
                        return reject({
                            level: 'error',
                            message: 'Processed encode did not meet max time slippage requirements.'
                        });
                    }
                    else {
                        resolve({
                            tempFileIndex: tempFileIndex,
                            original: originalMetadata,
                            new: metadata
                        });
                    }
                });
            });
        };


        let takeScreenshots = function(data) {
            return new Promise(function(resolve, reject) {
                if (!args.screenshots)
                    return resolve(data);

                logger.verbose('Taking screenshots...');

                let command = new ffmpeg(tempOutput);
                let commandIndex = temp.commandQueue.push(command);

                command
                    .on('filenames', function(filenames) {
                        if (filenames.length < 6)
                            logger.alert('Only generating', colors.yellow(filenames.length), 'screenshots.');
                    })
                    .on('end', function() {
                        _.pullAt(temp.commandQueue, commandIndex);
                        resolve(data);
                    });

                command.screenshots({
                    filename: '%f-%i.png',
                    folder: destinationDirectory,
                    count: 6
                });

            });
        };

        getMetadata(video)

        // Store original metadata
        .then(function(metadata) {
            return new Promise(function(resolve, reject) {
                originalMetadata = metadata;
                resolve(metadata);
            });
        })

        .then(processStreams)
            .then(upconvert)
            .then(setVideoBitDepth)
            .then(mapStreams)
            .then(setArguments)
            .then(encodeVideo)
            .then(verifyEncode)
            .then(takeScreenshots)
            .then(function(data) {
                logger.info('Processing', pathData.name + '.' + args.outputFormat, 'complete.');

                let ratio = (data.new.format.size / data.original.format.size * 100).toFixed(2);
                logger.info('Original', colors.yellow(filesize(data.original.format.size)), '\t', 'New', colors.yellow(filesize(data.new.format.size)), '\t', 'Ratio', colors.yellow(ratio));

                if (args.delete)
                    fs.removeSync(video);
                if (args.preview)
                    fs.removeSync(fileOutput);
                logger.verbose('Moving file to final destination. Wait for transfer confirmation message!');
                logger.debug('Output path:', fileOutput);
                fs.move(tempOutput, fileOutput, function(err) {
                    if (err)
                        throw err;

                    logger.verbose(pathData.name + '.' + args.outputFormat, 'transfered successfully.');
                    _.pullAt(temp.files, data.tempFileIndex);
                    cleanUp();
                });

                resolve();
            })
            .catch(function(err) {
                rejectedVideos[video] = err.message;
                if (err === 'ENDING') {
                    cleanUp(true);
                }
                else {
                    logger[err.level](err.message);
                    resolve();
                }
            });
    });
}

function finished() {

    logger.info('Folder encoding finished at', colors.yellow(moment().format("dddd, MMMM Do YYYY, h:mm:ss A")), {
        __divider: true
    });
    if (_.keys(rejectedVideos).length)
        logger.alert('The following videos', colors.yellow('(' + _.keys(rejectedVideos).length + ')'), 'were not encoded:', rejectedVideos);

}

// Helper Functions ------------------------------------------------------------

String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
};

function getSpeedRatio(timemark, elapsed) {

    let hours = parseInt(timemark.substring(0, timemark.indexOf(':')), 10);
    let minutes = parseInt(timemark.substring(timemark.indexOf(':') + 1, timemark.lastIndexOf(':')), 10);
    let seconds = parseFloat(timemark.substr(timemark.lastIndexOf(':') + 1));
    let secondsProcessed = hours * 60 * 60 + minutes * 60 + seconds;
    let secondsElapsed = elapsed / 1000;

    return (secondsProcessed / secondsElapsed).toFixed(3);
}

function userSetOption(option) {
    let formattedOption;
    if (option.length > 1) {
        formattedOption = '--' + option;
    }
    else {
        formattedOption = '-' + option;
    }

    if (process.argv.indexOf(option) > -1)
        return true;

    // Handle aliases for same option
    for (let aliasIndex in yargs.choices().parsed.aliases[option]) {
        let alias = yargs.choices().parsed.aliases[option][aliasIndex];
        let formattedAlias;
        if (alias.length > 1) {
            formattedAlias = '--' + alias;
        }
        else {
            formattedAlias = '-' + alias;
        }

        if (process.argv.indexOf(formattedAlias) > -1) {
            return true;
        }
    }

    return false;
}

function ifNotSetByUserSet(option, value) {

    if (userSetOption(option))
        return;

    args[option] = value;

    // Handle aliases for same option
    for (let aliasIndex in yargs.choices().parsed.aliases[option]) {
        let alias = yargs.choices().parsed.aliases[option][aliasIndex];
        args[alias] = value;
    }
}

function createListString(files) {
    if (Array.isArray(files))
        return '\n\t- ' + files.join('\n\t- ');

    let array = [];
    _.each(files, function(value, key) {
        array.push(colors.yellow(key) + ': ' + value);
    });
    return '\n\t- ' + array.join('\n\t- ');
}

function cleanUp(ending) {
    logger.verbose('Cleaning up temp files...');
    if (!args.debug) {
        _.each(temp.files, function(file) {
            try {
                fs.unlinkSync(file);
            }
            catch (err) {
                if (err.code !== 'ENOENT')
                    logger.error(err);
            }
        });
        temp.files.length = 0;
    }
    if (ending) {
        if (temp.files.length)
            logger.alert('The following temporary files were not deleted because you are in debug mode:', temp.files);

        logger.info('Process exited.');
        process.exit(0);

        if (temp.commandQueue.length)
            _.each(temp.commandQueue, function(command, i) {
                command.kill();
            });
    }
}


function extractTrack(videoPath, trackIndex) {
    return new Promise(function(resolve, reject) {
        if (!hasbin.sync('mkvextract')) {
            logger.warn('Upconvert skipped. mkvextract binary could not be located. Make sure you have it installed.');
            return reject({
                level: 'warn',
                message: 'MKVEXTRACT_NOT_INSTALLED'
            });
        }
        logger.debug('Extracting track', trackIndex, 'from', base);

        let base = path.basename(videoPath);
        let output = path.resolve(args.tempDirectory, base + '-track' + trackIndex);

        spawn('mkvextract', ['track', trackIndex + ':' + output])
            .on('close', (code) => {
                if (code !== 0) {
                    logger.warn('mkvextract exited with error code:', code);
                    logger.warn('Skipping video', path.filename + '.');
                    return reject({
                        level: 'error',
                        message: 'MKVEXTRACT_ERROR'
                    });
                }
                resolve(output);
            });

    });
}

function addx265Options(options) {
    args['x'] = options + (args['x'] ? (':' + args['x']) : '');
    args['extra-options'] = options + (args['extra-options'] ? (':' + args['extra-options']) : '');
}


function vobsubToSRT(filePath) {
    return new Promise(function(resolve, reject) {
        if (!hasbin.sync('vobsub2srt')) {
            logger.warn('Upconvert skipped. vobsub2srt binary could not be located. Make sure you have it installed.');
            return reject({
                level: 'warn',
                message: 'VOBSUB2SRT_NOT_INSTALLED'
            });
        }
        logger.debug('Converting', filePath, 'to srt file.');

        spawn('vobsub2srt', [filePath])
            .on('close', (code) => {
                if (code !== 0) {
                    logger.warn('vobsub2srt exited with error code:', code);
                    logger.warn('Skipping video', path.filename + '.');
                    return reject({
                        level: 'error',
                        message: 'VOBSUB2SRT_ERROR'
                    });
                }
                resolve(filePath + '.srt');
            });
    });
}

function getStreamTitle(stream) {
    return stream.title || stream.tags ? stream.tags.title : undefined;
}

function normalizeStreamLanguage(stream) {
    let lang = stream.language || stream.tags ? stream.tags.language : undefined;
    if (typeof lang === 'undefined')
        return 'Unknown';

    switch (lang.length) {
        case 2:
            return alpha2Languages[lang] || "Unknown";
        case 3:
            return alpha3Languages[lang] || "Unknown";
        default:
            return lang.capitalize() || "Unknown";
    }
}

function normalizeLanguage(lang) {
    if (typeof lang === 'undefined')
        return '';

    switch (lang.length) {
        case 2:
            return alpha2Languages[lang] || "Unknown";
        case 3:
            return alpha3Languages[lang] || "Unknown";
        default:
            return lang.capitalize() || "Unknown";
    }
}

function findVideos(path) {
    return new Promise(function(resolve, reject) {
        recursive(path, function(err, files) {

            // Handle any errors given while searching input directory
            if (err) {
                logger.debug('Error:', err);
                if (err.code === 'ENOENT')
                    return reject('File or directory ' + colors.yellow(input) + ' does not exist.');
                else
                    throw err;
            }


            // Check if each file is a video
            _.each(files, function(file) {
                if (mime.lookup(file).startsWith('video/'))
                    videos.push(file);
            });

            // Files is an array of filename
            logger.debug('Video files found: ', videos);

            resolve(videos);
        });
    });
}

var alpha2Languages = {
    "aa": "Afar",
    "ab": "Abkhazian",
    "ae": "Avestan",
    "af": "Afrikaans",
    "ak": "Akan",
    "am": "Amharic",
    "an": "Aragonese",
    "ar": "Arabic",
    "as": "Assamese",
    "av": "Avaric",
    "ay": "Aymara",
    "az": "Azerbaijani",
    "ba": "Bashkir",
    "be": "Belarusian",
    "bg": "Bulgarian",
    "bh": "Bihari languages",
    "bi": "Bislama",
    "bm": "Bambara",
    "bn": "Bengali",
    "bo": "Tibetan",
    "br": "Breton",
    "bs": "Bosnian",
    "ca": "Catalan; Valencian",
    "ce": "Chechen",
    "ch": "Chamorro",
    "co": "Corsican",
    "cr": "Cree",
    "cs": "Czech",
    "cu": "Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic",
    "cv": "Chuvash",
    "cy": "Welsh",
    "da": "Danish",
    "de": "German",
    "dv": "Divehi; Dhivehi; Maldivian",
    "dz": "Dzongkha",
    "ee": "Ewe",
    "el": "Greek: Modern (1453-)",
    "en": "English",
    "eo": "Esperanto",
    "es": "Spanish; Castilian",
    "et": "Estonian",
    "eu": "Basque",
    "fa": "Persian",
    "ff": "Fulah",
    "fi": "Finnish",
    "fj": "Fijian",
    "fo": "Faroese",
    "fr": "French",
    "fy": "Western Frisian",
    "ga": "Irish",
    "gd": "Gaelic; Scottish Gaelic",
    "gl": "Galician",
    "gn": "Guarani",
    "gu": "Gujarati",
    "gv": "Manx",
    "ha": "Hausa",
    "he": "Hebrew",
    "hi": "Hindi",
    "ho": "Hiri Motu",
    "hr": "Croatian",
    "ht": "Haitian; Haitian Creole",
    "hu": "Hungarian",
    "hy": "Armenian",
    "hz": "Herero",
    "ia": "Interlingua (International Auxiliary Language Association)",
    "id": "Indonesian",
    "ie": "Interlingue; Occidental",
    "ig": "Igbo",
    "ii": "Sichuan Yi; Nuosu",
    "ik": "Inupiaq",
    "io": "Ido",
    "is": "Icelandic",
    "it": "Italian",
    "iu": "Inuktitut",
    "ja": "Japanese",
    "jv": "Javanese",
    "ka": "Georgian",
    "kg": "Kongo",
    "ki": "Kikuyu; Gikuyu",
    "kj": "Kuanyama; Kwanyama",
    "kk": "Kazakh",
    "kl": "Kalaallisut; Greenlandic",
    "km": "Central Khmer",
    "kn": "Kannada",
    "ko": "Korean",
    "kr": "Kanuri",
    "ks": "Kashmiri",
    "ku": "Kurdish",
    "kv": "Komi",
    "kw": "Cornish",
    "ky": "Kirghiz; Kyrgyz",
    "la": "Latin",
    "lb": "Luxembourgish; Letzeburgesch",
    "lg": "Ganda",
    "li": "Limburgan; Limburger; Limburgish",
    "ln": "Lingala",
    "lo": "Lao",
    "lt": "Lithuanian",
    "lu": "Luba-Katanga",
    "lv": "Latvian",
    "mg": "Malagasy",
    "mh": "Marshallese",
    "mi": "Maori",
    "mk": "Macedonian",
    "ml": "Malayalam",
    "mn": "Mongolian",
    "mr": "Marathi",
    "ms": "Malay",
    "mt": "Maltese",
    "my": "Burmese",
    "na": "Nauru",
    "nb": "Bokmål: Norwegian; Norwegian Bokmål",
    "nd": "Ndebele: North; North Ndebele",
    "ne": "Nepali",
    "ng": "Ndonga",
    "nl": "Dutch; Flemish",
    "nn": "Norwegian Nynorsk; Nynorsk: Norwegian",
    "no": "Norwegian",
    "nr": "Ndebele: South; South Ndebele",
    "nv": "Navajo; Navaho",
    "ny": "Chichewa; Chewa; Nyanja",
    "oc": "Occitan (post 1500); Provençal",
    "oj": "Ojibwa",
    "om": "Oromo",
    "or": "Oriya",
    "os": "Ossetian; Ossetic",
    "pa": "Panjabi; Punjabi",
    "pi": "Pali",
    "pl": "Polish",
    "ps": "Pushto; Pashto",
    "pt": "Portuguese",
    "qu": "Quechua",
    "rm": "Romansh",
    "rn": "Rundi",
    "ro": "Romanian; Moldavian; Moldovan",
    "ru": "Russian",
    "rw": "Kinyarwanda",
    "sa": "Sanskrit",
    "sc": "Sardinian",
    "sd": "Sindhi",
    "se": "Northern Sami",
    "sg": "Sango",
    "si": "Sinhala; Sinhalese",
    "sk": "Slovak",
    "sl": "Slovenian",
    "sm": "Samoan",
    "sn": "Shona",
    "so": "Somali",
    "sq": "Albanian",
    "sr": "Serbian",
    "ss": "Swati",
    "st": "Sotho: Southern",
    "su": "Sundanese",
    "sv": "Swedish",
    "sw": "Swahili",
    "ta": "Tamil",
    "te": "Telugu",
    "tg": "Tajik",
    "th": "Thai",
    "ti": "Tigrinya",
    "tk": "Turkmen",
    "tl": "Tagalog",
    "tn": "Tswana",
    "to": "Tonga (Tonga Islands)",
    "tr": "Turkish",
    "ts": "Tsonga",
    "tt": "Tatar",
    "tw": "Twi",
    "ty": "Tahitian",
    "ug": "Uighur; Uyghur",
    "uk": "Ukrainian",
    "ur": "Urdu",
    "uz": "Uzbek",
    "ve": "Venda",
    "vi": "Vietnamese",
    "vo": "Volapük",
    "wa": "Walloon",
    "wo": "Wolof",
    "xh": "Xhosa",
    "yi": "Yiddish",
    "yo": "Yoruba",
    "za": "Zhuang; Chuang",
    "zh": "Chinese",
    "zu": "Zulu",
    "un": "Unknown",
};
var alpha3Languages = {
    "aar": "Afar",
    "abk": "Abkhazian",
    "afr": "Afrikaans",
    "aka": "Akan",
    "alb": "Albanian",
    "amh": "Amharic",
    "ara": "Arabic",
    "arg": "Aragonese",
    "arm": "Armenian",
    "asm": "Assamese",
    "ava": "Avaric",
    "ave": "Avestan",
    "aym": "Aymara",
    "aze": "Azerbaijani",
    "bak": "Bashkir",
    "bam": "Bambara",
    "baq": "Basque",
    "bel": "Belarusian",
    "ben": "Bengali",
    "bih": "Bihari languages",
    "bis": "Bislama",
    "bos": "Bosnian",
    "bre": "Breton",
    "bul": "Bulgarian",
    "bur": "Burmese",
    "cat": "Catalan; Valencian",
    "cha": "Chamorro",
    "che": "Chechen",
    "chi": "Chinese",
    "chu": "Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic",
    "chv": "Chuvash",
    "cor": "Cornish",
    "cos": "Corsican",
    "cre": "Cree",
    "cze": "Czech",
    "dan": "Danish",
    "div": "Divehi; Dhivehi; Maldivian",
    "dut": "Dutch; Flemish",
    "dzo": "Dzongkha",
    "eng": "English",
    "epo": "Esperanto",
    "est": "Estonian",
    "ewe": "Ewe",
    "fao": "Faroese",
    "fij": "Fijian",
    "fin": "Finnish",
    "fre": "French",
    "fry": "Western Frisian",
    "ful": "Fulah",
    "geo": "Georgian",
    "ger": "German",
    "gla": "Gaelic; Scottish Gaelic",
    "gle": "Irish",
    "glg": "Galician",
    "glv": "Manx",
    "gre": "Greek, Modern (1453-)",
    "grn": "Guarani",
    "guj": "Gujarati",
    "hat": "Haitian; Haitian Creole",
    "hau": "Hausa",
    "heb": "Hebrew",
    "her": "Herero",
    "hin": "Hindi",
    "hmo": "Hiri Motu",
    "hrv": "Croatian",
    "hun": "Hungarian",
    "ibo": "Igbo",
    "ice": "Icelandic",
    "ido": "Ido",
    "iii": "Sichuan Yi; Nuosu",
    "iku": "Inuktitut",
    "ile": "Interlingue; Occidental",
    "ina": "Interlingua (International Auxiliary Language Association)",
    "ind": "Indonesian",
    "ipk": "Inupiaq",
    "ita": "Italian",
    "jav": "Javanese",
    "jpn": "Japanese",
    "kal": "Kalaallisut; Greenlandic",
    "kan": "Kannada",
    "kas": "Kashmiri",
    "kau": "Kanuri",
    "kaz": "Kazakh",
    "khm": "Central Khmer",
    "kik": "Kikuyu; Gikuyu",
    "kin": "Kinyarwanda",
    "kir": "Kirghiz; Kyrgyz",
    "kom": "Komi",
    "kon": "Kongo",
    "kor": "Korean",
    "kua": "Kuanyama; Kwanyama",
    "kur": "Kurdish",
    "lao": "Lao",
    "lat": "Latin",
    "lav": "Latvian",
    "lim": "Limburgan; Limburger; Limburgish",
    "lin": "Lingala",
    "lit": "Lithuanian",
    "ltz": "Luxembourgish; Letzeburgesch",
    "lub": "Luba-Katanga",
    "lug": "Ganda",
    "mac": "Macedonian",
    "mah": "Marshallese",
    "mal": "Malayalam",
    "mao": "Maori",
    "mar": "Marathi",
    "may": "Malay",
    "mlg": "Malagasy",
    "mlt": "Maltese",
    "mon": "Mongolian",
    "nau": "Nauru",
    "nav": "Navajo; Navaho",
    "nbl": "Ndebele, South; South Ndebele",
    "nde": "Ndebele, North; North Ndebele",
    "ndo": "Ndonga",
    "nep": "Nepali",
    "nno": "Norwegian Nynorsk; Nynorsk, Norwegian",
    "nob": "Bokmål, Norwegian; Norwegian Bokmål",
    "nor": "Norwegian",
    "nya": "Chichewa; Chewa; Nyanja",
    "oci": "Occitan (post 1500); Provençal",
    "oji": "Ojibwa",
    "ori": "Oriya",
    "orm": "Oromo",
    "oss": "Ossetian; Ossetic",
    "pan": "Panjabi; Punjabi",
    "per": "Persian",
    "pli": "Pali",
    "pol": "Polish",
    "por": "Portuguese",
    "pus": "Pushto; Pashto",
    "que": "Quechua",
    "roh": "Romansh",
    "rum": "Romanian; Moldavian; Moldovan",
    "run": "Rundi",
    "rus": "Russian",
    "sag": "Sango",
    "san": "Sanskrit",
    "sin": "Sinhala; Sinhalese",
    "slo": "Slovak",
    "slv": "Slovenian",
    "sme": "Northern Sami",
    "smo": "Samoan",
    "sna": "Shona",
    "snd": "Sindhi",
    "som": "Somali",
    "sot": "Sotho, Southern",
    "spa": "Spanish; Castilian",
    "srd": "Sardinian",
    "srp": "Serbian",
    "ssw": "Swati",
    "sun": "Sundanese",
    "swa": "Swahili",
    "swe": "Swedish",
    "tah": "Tahitian",
    "tam": "Tamil",
    "tat": "Tatar",
    "tel": "Telugu",
    "tgk": "Tajik",
    "tgl": "Tagalog",
    "tha": "Thai",
    "tib": "Tibetan",
    "tir": "Tigrinya",
    "ton": "Tonga (Tonga Islands)",
    "tsn": "Tswana",
    "tso": "Tsonga",
    "tuk": "Turkmen",
    "tur": "Turkish",
    "twi": "Twi",
    "uig": "Uighur; Uyghur",
    "ukr": "Ukrainian",
    "urd": "Urdu",
    "uzb": "Uzbek",
    "ven": "Venda",
    "vie": "Vietnamese",
    "vol": "Volapük",
    "wel": "Welsh",
    "wln": "Walloon",
    "wol": "Wolof",
    "xho": "Xhosa",
    "yid": "Yiddish",
    "yor": "Yoruba",
    "zha": "Zhuang; Chuang",
    "zul": "Zulu"
};
